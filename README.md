[未来网络 - 寻路](http://codecraft.huawei.com/home/index)
=================

2016年华为软件精英挑战赛全国总冠军(国防科大-六院八队)代码开源啦!

本项目为复赛/决赛开源代码, 初赛代码为复赛问题的子问题.
本代码为决赛前一晚最终确定的版本, 我队在决赛中做了些小的参数调整(如迭代次数等), 所以运行结果可能与决赛结果有细微差别, 除此之外, 没有其他差别

另外, 附上matlab写的一个复赛用例的随机生成器(matlab), 见data_generator


赛题说明
--------

见doc/下的题目描述文档


基本算法
--------

概况: [LKH](http://www.akira.ruc.dk/~keld/research/LKH/)解决初赛问题, 加上两次寻路多次互设惩罚迭代

### 初赛问题解决方案

#### 基本步骤

1. 使用spfa或dij求出必经点之间的最短路径和距离
2. 使用上一步骤求得的距离对必经点(包括s, t)使用LKH算法求tsp问题
3. 由上两步还原出初赛问题的解
4. 若上一步步骤中出现重复经过的结点, 则将重复经过的结点升级设置为必经点, 转步骤1, 否则problem solved.

#### 改进

若将重复结点升级为必经点后导致无解, 则不将重复结点升级, 而是对这些重复结点(比如x1, x2, ...)添加辅助结点(y0(=t), y1, y2, ...); 然后添加边(yi, yi+1), (yi, xi+1), (xi+1, yi+1), 边的权重为0, 再跑tsp; 则利用得到的哈密顿路径从s到y0和基本步骤1可以得到初始问题的解. 优先使用升级重复点的方法主要是考虑运行效率

另一个改进是, LKH的opt算法使用有向的opt.

本项目的整个算法的**主要耗时都花在了spfa上**, 在重复"升级重复结点, 跑spfa, 跑tsp"这一步骤中, 重复结点只增不减, 故可以利用上次spfa的结果来减少当前spfa的计算次数, 这一点在决赛中并没有好的效果, 原因在于决赛官方case的规模并不算大

### 复赛问题解决方案

### 基本步骤

1. 利用初赛问题解决方案求主路径tour1
2. 将tour1中用到的边加上惩罚值, 比如一个比1999 * 100还要大的一个权
3. 利用初赛问题解决方案求备用路径tour2
4. 将tour2中用到的边加上惩罚值, 比如一个比1999 * 100还要大的一个权
5. 反复进行以上1~4步, 直到时间到达时限或解不再变化或迭代次数上限.

#### 改进

调换求tour1, tour2的顺序, 再来一遍

两种惩罚方案: 1) 重复边多时, 固定惩罚值(>= 19999 * 100); 2) 增量式惩罚值, 开始为10, 求一次tour加10

对于某个tour1, 如果另一条tour2解用到了两端都是tour1的必经点的边, 那么这条边不设惩罚

在spfa过程中, **随机**选择顺序枚举邻接表还是逆倒序枚举邻接表, 减少重复边

在迭代过程中, 解会重复出现, 使用hash保存结果避免重算


运行说明
--------

使用华为官方SDK-gcc-2.0, 官方readme见doc/readme.txt

如果**机器较慢, 可以把时限调大一点, 否则将影响运行结果**

在data文件夹中附上决赛我们用的例子一枚(topo1800)


交流与讨论
----------

关于本项目的所有编码上的, 算法上的问题, 欢迎邮件或QQ等方式同我们交流

QQ: 452570607(易) 912385457(王) 799279601(韩)
